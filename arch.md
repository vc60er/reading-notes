## 索引
### b tree & b+ tree
b:
树内的每个节点都存储数据
叶子节点之间无指针相邻

b+:
数据只出现在叶子节点
所有叶子节点增加了一个链指针

针对上面的B+树和B树的特点，我们做一个总结
(1)B树的树内存储数据，因此查询单条数据的时候，B树的查询效率不固定，最好的情况是O(1)。我们可以认为在做单一数据查询的时候，使用B树平均性能更好。但是，由于B树中各节点之间没有指针相邻，因此B树不适合做一些数据遍历操作。

(2)B+树的数据只出现在叶子节点上，因此在查询单条数据的时候，查询速度非常稳定。因此，在做单一数据的查询上，其平均性能并不如B树。但是，B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做范围查询。




## 笔记
- [面试官:谈谈你对mysql联合索引的认识？](https://www.cnblogs.com/rjzheng/p/12557314.html)
*联合索引*
1. 前缀匹配（最左匹配原则）
2. 遇到范围查询（>、<、between、like）之后停止匹配（范围查询后的条件索引失效），
3. 条件中列的顺序，会被优化器按照索引的顺序来优化

*索引的列*
索引的列，如果是全部的select列，则不需要再次回表查询
索引的列，可用于优化排序





- [为什么Redis集群有16384个槽](https://www.cnblogs.com/rjzheng/p/11430592.html)
出于带宽考虑




- [关于DNS不得不说的一些事](https://www.cnblogs.com/rjzheng/p/11395695.html)

- [面试官:讲讲mysql表设计要注意啥](https://www.cnblogs.com/rjzheng/p/11174714.html)
问题1:为什么一定要设一个主键？
	主键会被用于聚合索引，没有定义的情况下，系统会定义一个隐藏的主键，如果显示定义自己的主键，再次再此键上的查询能到达最优

问题2:主键是用自增还是UUID?
	自增id能保证新插入的id是最大值，所以会被保存在聚合缩影的末尾
	uuid不能保证新插入的id是最大值，会造成在聚合索引上的随机插入，从而引发页的分裂

问题3:主键为什么不推荐有业务含义?
	有业务含义，意味着
	有可能被修改，修改主键上的值成本比较高
	有可能不是自增的

问题4:表示枚举的字段为什么不用enum类型？
	回答:在工作中表示枚举的字段，一般用tinyint类型。
	那为什么不用enum类型呢？下面两个原因
	(1)ENUM类型的ORDER BY操作效率低，需要额外操作
	(2)如果枚举值是数值，有陷阱	

问题5:货币字段用什么类型?
	回答:如果货币单位是分，可以用Int类型。如果坚持用元，用Decimal。
	千万不要答float和double，因为float和double是以二进制存储的，所以有一定的误差。
	打个比方，你建一个列如下

	CREATE TABLE `t` (
	  `price` float(10,2) DEFAULT NULL,
	) ENGINE=InnoDB DEFAULT CHARSET=utf8
	然后insert给price列一个数据为1234567.23，你会发现显示出来的数据变为1234567.25，精度失准！

问题6:时间字段用什么类型?
	varchar：做时间比较运算，你需要用STR_TO_DATE等函数将其转化为时间类型，你会发现这么写是无法命中索引的
	timestamp：四个字节的整数，2038年以后的时间，是无法用timestamp类型存储的。但是它有一个优势，timestamp类型是带有时区信息的
	datetime：占用8个字节，他存储的是时间绝对值，不带有时区信息

问题7:为什么不直接存储图片、音频、视频等大容量内容?
	读取数据是按照行读取的

问题8:字段为什么要定义为NOT NULL?
	(1)索引性能不好
	Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。	
	(2)查询会出现一些不可预料的结果



[【原创】杂谈自增主键用完了怎么办)](https://www.cnblogs.com/rjzheng/p/10669043.html)

把自增主键的类型改为BigInt类型就好了！
对于修改数据类型这种操作，是不支持并发的DML操作！也就是说，如果你直接使用ALTER这样的语句在线修改表数据结构，会导致这张表无法进行更新类操作(DELETE、UPDATE、DELETE)。

使用第三方工具gh-ost，pt-osc
主存切换




[【原创】分布式之redis复习精讲](https://www.cnblogs.com/rjzheng/p/9096228.html)

2、使用redis有什么缺点
分析:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。
回答:主要是四个问题
(一)缓存和数据库双写一致性问题
(二)缓存雪崩问题
(三)缓存击穿问题
(四)缓存的并发竞争问题
这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。


3、单线程的redis为什么这么快
回答:主要是以下三点
(一)纯内存操作
(二)单线程操作，避免了频繁的上下文切换
(三)采用了非阻塞I/O多路复用机制


4、redis的数据类型，以及每种数据类型的使用场景

5、redis的过期策略以及内存淘汰机制

过期策略
	定期随机抽查，redis默认每个100ms检查
	惰性删除，在使用的时候，检查时否过期
淘汰机制
	1）noeviction：拒绝写入新数据
	2）allkeys-lru：在键空间中，移除最近最少使用的key
	3）allkeys-random：在键空间中，随机移除某个key。
	4）volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key。
	5）volatile-random：在设置了过期时间的键空间中，随机移除某个key
	6）volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的key优先移除


6、redis和数据库双写一致性问题


7、如何应对缓存穿透和缓存雪崩问题

缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。
解决方案:
(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。

缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
解决方案:
(一)给缓存的失效时间，加上一个随机值，避免集体失效。
(二)使用互斥锁，但是该方案吞吐量明显下降了。
(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。




map的现实
两种实现方法
开放寻址法：只有数组，冲突后，探测数组中的下一个索引的数据
拉链法：数组加上链表实现，冲突后，连接到连标上
搜索树法一般采用自平衡搜索树，包括：AVL 树，红黑树

