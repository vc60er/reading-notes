# 《数据库系统内幕》笔记

# 第一部分：存储引擎

本书既不是关于关系型数据库的书，也不是关于NoSql的书，而是关于各种数据库系统中使用的算法和概念的书，且重点是存储引擎和负责数据分布的组建

## 第一章. 简介与概述


### 数据类型

1. 内存数据库：主要讲数据存储在内存中，并使用磁盘进行数据恢复和日志记录
2. 磁盘数据库：将大部分数据保存在磁盘上，并使用内存来缓存磁盘内容作为临时存储。
3. 面向列的数据库：将数据按照列存储，同一列的数据连续存储在一起，数据具有相同的数据类型，提高了压缩率，跨多行扫描数据，在列的子集上进行聚合时比较有优势
4. 面向行的数据库：将数据按照行存储，同一行的数据连续存储在一起，数据具有较好的局部性，读取数据是需要整行读取。
5. 宽列是存储：数据表示为多维映射，列被分组为列族（通常存储相同类型的数据），并且在每个列族中，数据被逐行存储。此布局最是适合存储有一个键或者一组键类检索的数据


### 数据文件和索引文件

数据文件:

数据文件存储数据记录，文件被划分成页，每页具有单个或者多个磁盘块的大小，大多数现代存储系统都不显示的删除页上的数据，相反他们使用标记删除

索引文件:

是一种未来高效检索数据而对磁盘上的数据进行组织的结构，



## B数基础支持

1. 二叉搜索树
一个节点的键大于其左子树总存储的任何键，且小于其右子树中存储的任何键
2. 




# 第二部分：分布式系统

## 分布式系统面临的问题
1. 网络不可靠
	* 网络不可达
	* 链接中断
	* 请求到达，并处理，但是对端的响应丢失 
 	* 延迟不确定
2. 请求处理不是瞬时的
	+ 消息可能进入远程机器的队列中，等待被处理，
	+ 队列的大小取决于
3. 时钟不可靠
	+ 不同参与者的时钟不同步
	+ 时钟不一定单调递增
4. 服务端状态不一致
	+ 分布式算法不总是状态一致，异常数据，总是在被读取时修复或者冲突时解决
5. 本地和远程执行存在较大差异
6. 故障处理
	+ 总有其中的某个部分会出现问题
7. 网络分区和部分故障
8. 级联故障
	+ 某个部分的故障可能引起其他依赖方的故障，需要通过熔断，退避，验证和协调机制来保护

## 故障检测

负责识别故障或者无法到的进程，将它们排出在外，并在维护安全性的同时保证算法的活动性
>* 活动性：保证特定预期事件必须发生。比如，其中一个进程发生故障，则故障检测器必须检测到该故障。
>* 安全性：保证意外事件不会发生。比如，故障检测器已经将一个进程标记为死亡，那么这个进程必须是死亡的。

故障检测的难点在于如何将运行缓慢和故障区分开。

### 检测远程存活状态的办法：

1. ping：过向远端发送ping，并且等待远端回复的response，通过在指定时间内是否收到回复来判断其是否存活
2. 心跳：向对方发送心跳，主动通知对方，其仍在运行

### 无超时的故障检测

原理：

每个进程维护一个邻居列表，其中保存各邻居心跳计数。心跳包中包含一个传播路径，记录心跳途径的进程。邻居收到心跳包后，根据途径路径进程累加相应进程的心跳次数。最后，推断出心跳最少的邻居为故障进程。

```go
type map[neighborhood]hbCount HeartbeatList

type Heartbeat_msg struct {
	pass_path []string
	msg_id int64
}
```

todo: pic

步骤：

1. 每个进程维护一个邻居列表，其中保存个邻居心跳计数
2. 向邻居发送心跳消息，心跳消息中包含消息ID，和到目前为止途径的进程
3. 接收到消息时，根据消息的传播路径，增加相应邻居的心跳数。
4. 将心跳包发送给尚未参与的进程，并将自身追加到传播路径
5. 如果看到所有已知进程都已接消息，就停止传播消息
6. 检查心跳计数器，认为心跳最少的进程位故障进程

实现：

AGUILERA97

### 外包心跳

原理：

从相邻进程的角度来看进程的活动性，即，当心跳不通的时候，尝试通过其他节点中转心跳，如果中转心跳也不通，则认为故障

todo: pic

步骤：

1. p1向p2发送ping，p2没有回应
2. p1随机选择p3,p4向p2发送数据，如果p2响应，则将结果反馈给p1

实现

Scalable Weakly Consistent Infection-style Process Group Membership Protocol, SWIM

### phi增量故障检测器-cassandra,akka

原理:

步骤:

// todo


### Gossip和故障检测

原理:

维护一个包含所有成员的心跳列表，记录心跳次数和时间，定期更新自己的心跳次数和时间，并向邻居传播心跳列表，邻居收到列表之后，与本地列表合并保留最新值。最后，推断出长时间未更新心跳的成员为故障成员


```go
map[neaberhud]{hbTimes, hbTimestamp}

```

todo: pic


步骤:

1. 每个进程维护一个包好所有成员的列表，记录对应成员的心跳次数和心跳时间。
2. 每个成员定期递增自己的心跳次数和时间，并通过心跳消息将本地列表发送给随机的邻居
3. 成员收到心跳消息时，将消息中的列表与本地列表合并，最终保留各成员最近的心跳次数和心跳时间
4. 成员定期检查成员列表，在足够成的时间内没有更新过心跳次数的成员，被认为是鼓掌成员。

实现：

VANRENESSE98


## 选举

选举的过程中必须产生一个领导者，这一决定必须对所有参与者都有效。


### 霸道选举算法

原理:

给进程添加序号，通过选择最大序号的办法找到新的领导者

步骤:

1. 发现系统中没有领导者
2. 向所有比其具有更高标识符的进程发送选举消息
3. 从回应中，选择最大的标识符的进程作为领导者
4. 如果没有回应，选择自己作为领导者
5. 新的领导者，给所有具有更低标识符的进程发送通知

实现：

MOLINA82



### 带故障转移的霸道选举算法

原理:

试图解决由于最高排名的节点不稳定，导致领导者不稳定的情况。为领导者引入了故障转移节点，领导者故障时候，从故障转移节点中选择新的领导者

步骤:

1. 新的领导者提供一个故障转移节点（备选节点）的列表，
2. 当新的领导者出现故障时，发现者向备选节点发起新一轮选举
3. 如果发现这是备选节点中排名最高的节点，则它成为新的领导者

实现：

GHOLIPOUR09


### 候选节点/普通节点优化

原理:

试图解决由于最高排名的节点不稳定，导致领导者不稳定的情况，仅从领导者候选节点中选择领导者

步骤:

1. 将所有节点分成两个子集，候选节点和普通节点
2. 普通节点向候选节点发起选举请求
3. 收到候选节点的响应后，选择排名最高的最为候选节点作为新的领导者
4. 通知其余其余节点

实现：

MURSHED12


### 邀请算法

原理:

通过领导者之间的协商，按照大组合并小组的规则，合并形成一个大组，选出领导者

步骤:

1. 每个进程一开始都属于一个新组，并且是领导者，组内只有它自己
2. 组领导者邀请不属于该组的对等进程加入改组
3. 如果对方也是领导者，则两组合并，组大的领导者，成为新的领导者，并通知较小组的成员
4. 如果对方不是领导者，返回他们组领导者的ID
5. 最终所有组合并成了一个大组和一个领导者

实现：





### 环形算法

原理:

在环上传播选举消息，并筛选出来了活跃节点集合，从活跃节点集合中选择排名最高的作为领导者。

步骤:

1. 所有节点组成一个环，并且知道拓扑
2. 当发现领导者故障时，发起选举，选举消息沿着环向后继节点转发
3. 如果遇到后继节点不可用，则跳过此节点
4. 在转发选举消息的时候，将自己添加到活动节点集合，一并转发给后继节点
5. 当选举消息到达始发节点时，从活动节点集合中，选择排名最高的节点作为领导者
6. 沿着环通知其余节点


实现：

CHANG79



## 复制和一致性

todo

## 反熵和传播

熵表示节点之间分歧程度，反熵表示去除这种分歧程度的过程

### 传播的三个方法：

1. 点进程广播
2. 点对点交换
3. 合作广播


todo： pic

### 广播存在的问题：

1. 大集群中，广播会变得很昂贵
2. 存在单点故障
3. 各进程并不总是知道其他进程的存在
4. 广播的进程及其他每个进程都必须在工作时间上有重叠


### 反熵：

为了保持各节点的同步，反熵会触发一个后台和前台进程，比较和调和丢失或冲突的记录。
1. 后台进程会利用Merkle树之类的辅助数据结构，从更新日志中识别出来分歧的数据
2. 前台进程会稍带地在读取或者写入请求熵附加额外逻辑，比如提示移交，读修复等。


### 读修复

协调者向各副本发出读请求，等待副本响应并对其进行比较，如果检测出某个副本的数据不一致，然后将差异发送给该副本

### 摘要读

协调者只向一个副本发送完全读请求，向其他副本发送数据摘要（数据哈希值）读请求。如果某个副本的数据摘要不匹配，协调者向其发送完全读请求，比较它们的响应，找出差异之处，然后将差异发送给该副本

### 提示移交

向某个节点写入数据失败时，则记录一条特殊的记录，称为：提示（hit）。当这个节点恢复后，该记录会立刻被回放。

### Merkle树

Merkle树是一个对本地数据的紧凑的哈希表示，它是一颗由哈希值构成的二叉树。较高层级来自对较低层级的哈希值再次进行哈希。

todo：pic

通过比较树根节点的值，可以快速判断两个副本是否一致，通过递归遍历哈希树节点来缩小不一致的范围

### 位图版本向量

原理：

位图版本向量是由一个整数n表示前n项目连续，一些列bit表示第n项之后不连续的多项目构成，表示为（n, bit...)。例如（3，010101）表示前3项目连续，之后不连续，其中第4，6，8项缺失。

todo：pic

步骤：

1. 每个节点各维护一份所有节点的位图版本向量，以及各个节点的位图版本向量中不连续部分的更新日志
2. 写入请求（直接或间接）需要带有写入标识（i，n），表示节点n的第i次写入。
3. 收到写入请求后根据写入标识（i，n）更新相应节点的位图向量，
4. 在反熵时，通过交换为图版本向量，识别出来缺失的写入，然后复制与之关联的数据记录，
5. 如果所有节点维护的某个节点的位图版本向量的前x项已连续，则将此节点的位图版本向量的连续部分更新为x

实现：

GONCALVES15

### Gossip

todo


## 分布式事务

## 共识









