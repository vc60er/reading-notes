#《数据库系统内幕》笔记


本书既不是关于关系型数据库的书，也不是关于NoSql的书，而是关于各种数据库系统中使用的算法和概念的书，且重点是存储引擎和负责数据分布的组建

## 第一章. 简介与概述


### 数据类型

1. 内存数据库：主要讲数据存储在内存中，并使用磁盘进行数据恢复和日志记录
2. 磁盘数据库：将大部分数据保存在磁盘上，并使用内存来缓存磁盘内容作为临时存储。
3. 面向列的数据库：将数据按照列存储，同一列的数据连续存储在一起，数据具有相同的数据类型，提高了压缩率，跨多行扫描数据，在列的子集上进行聚合时比较有优势
4. 面向行的数据库：将数据按照行存储，同一行的数据连续存储在一起，数据具有较好的局部性，读取数据是需要整行读取。
5. 宽列是存储：数据表示为多维映射，列被分组为列族（通常存储相同类型的数据），并且在每个列族中，数据被逐行存储。此布局最是适合存储有一个键或者一组键类检索的数据


### 数据文件和索引文件

数据文件:

数据文件存储数据记录，文件被划分成页，每页具有单个或者多个磁盘块的大小，大多数现代存储系统都不显示的删除页上的数据，相反他们使用标记删除

索引文件:

是一种未来高效检索数据而对磁盘上的数据进行组织的结构，



## B数基础支持

1. 二叉搜索树
一个节点的键大于其左子树总存储的任何键，且小于其右子树中存储的任何键
2. 


## 分布式系统面临的问题
1. 网络不可靠
>a.网络不可达
>b.链接中断
>c.请求到达，并处理，但是对端的响应丢失 
>d.延迟不确定
>
2. 请求处理不是瞬时的
>消息可能进入远程机器的队列中，等待被处理，
>队列的大小取决于
3. 时钟不可靠
>不同参与者的时钟不同步
>时钟不一定单调递增
4. 服务端状态不一致
>分布式算法不总是状态一致，异常数据，总是在被读取时修复或者冲突时解决
5. 本地和远程执行存在较大差异
6. 故障处理
>总有其中的某个部分会出现问题
7. 网络分区和部分故障
8. 级联故障
>某个部分的故障可能引起其他依赖方的故障，需要通过熔断，退避，验证和协调机制来保护

## 故障检测

### 检测远程存活状态的办法：

1. ping： 通过向远端发送ping，并且等待远端的response，来判断远端是否存活
2. 心跳：通过向对方发送心跳，主动通知对方，其仍在运行

### 无超时的故障检测-Heartbeat

原理：

向邻居传播心跳，心跳中记录传播路径，接收方根据传播路径，递增心跳计数器，更加心跳计数器，判断已经故障的节点

步骤：

1. 每个进程维护一个邻居列表，其中存其心跳计数器
2. 向邻居发送心跳消息，心跳消息中包含消息ID，始法人，以及到目前为止的所有经过的节点的路径
3. 接收到消息时，递增路径中参与者的心跳计数器，
4. 将心跳包发送给尚未参与的进程，并将自身追加到路径中
5. 如果看到所有已知进程都已接消息，就停止传播消息
6. 检查心跳计数器，如果较小，则认为故障 // todo

### 外包心跳-swim

原理：

当心跳不通的时候，尝试通过其他节点中转心跳，如果中转心跳也不通，则认为故障

步骤：

1. p1向p2发送ping，p2没有回应
2. p1通过p3,p4向p2发送数据，如果p2响应，则将结果反馈给p1



### phi增量故障检测器-cassandra,akka

原理:

步骤:

// todo

### Gossip和故障检测

原理:

向邻居发送心跳，并记录成果的时间戳，并把心跳时间戳同步给邻居，使得心跳时间戳随着心跳传播至所有节点，最后通过最小心跳时间戳，判断故障节点

步骤:

1. 每个进程维护一个其他成员的列表，记录对其发送心跳的次数和时间戳
2. 向邻居的进程发送心跳，成功后对相应的邻居递增心跳次数，更新时间戳，然后将列表发送给邻居
3. 收到列表之后，与自己只有的列表合并，保留时间戳最新的数据
4. 检查列表， 如果长时间内没有更新时间戳，则认为故障

## 选举
### 霸道选举算法

原理:

对进程设置有序的标识符，通过选择最大标识符的办法找到新的领导者

步骤:

1. 发现系统中没有领导者
2. 向所有比其具有更高标识符的进程发送选举消息
3. 从回应中，选择最大的标识符的进程作为领导者
4. 如果没有回应，选择自己作为领导者
5. 新的领导者，给所有具有更低标识符的进程发送通知


### 带故障转移的霸道选举算法

原理:

试图解决由于最高排名的节点不稳定，导致领导者不稳定的情况，为领导这引入了故障转移节点，领导者故障时候，从故障转移节点中选择新的领导者

步骤:

1. 新的领导者提供一个故障转移节点（备选节点）的列表，
2. 当新的领导者出现故障时，发现者想被选节点发起新一轮选举
3. 如果发现这是备选节点中排名最高的节点，则它成为新的领导者


### 候选节点/普通节点优化

原理:

试图解决由于最高排名的节点不稳定，导致领导者不稳定的情况，仅从领导者候选节点中选择领导者

步骤:

1. 将所有节点分成两个子集，候选节点和普通节点
2. 普通节点向候选节点发起选举请求
3. 收到候选节点的响应后，选择排名最高的最为候选节点作为新的领导者
4. 通知其余其余节点


### 邀请算法

原理:

通过领导者之间的协商，按照大组合并小组的规则，合并形成一个大组，选出领导者

步骤:

1. 每个进程一开始都属于一个新组，并且是领导者，组内只有它自己
2. 组领导者邀请不属于该组的对等进程加入改组
3. 如果对方也是领导者，则两组合并，组大的领导者，成为新的领导者，并通知较小组的成员
4. 如果对方不是领导者，返回他们组领导者的ID
5. 最终所有组合并成了一个大组和一个领导者

### 环形算法

原理:

在环上传播选举消息，通过传播选举消息，筛选出来了活跃节点集合，从活跃节点结合中选择排名最高的作为领导者。

步骤:

1. 所有节点组成一个环，并且知道拓扑
2. 当发现领导者故障时，发起选举，选举消息沿着环向后继节点转发
3. 如果遇到后继节点不可用，则跳过此节点
4. 在转发选举消息的时候，将自己添加到活动节点集合，一并转发给后继节点
5. 当选举消息到达始发节点时，从活动节点集合中，选择排名最高的节点作为领导者
6. 沿着环通知其余节点

















