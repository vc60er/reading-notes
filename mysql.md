## 索引
### 底层算法
1. btree
2. hash
3. rtree

### 数据存储
1. 聚合索引
2. 非聚合索引

### 类型
- 主键索引
- 唯一索引
- 普通索引
- 联合缩影
- 全文索引
- 前缀索引


## 锁

## 事务

## 引擎









## 资源
http://blog.codinglabs.org/articles/theory-of-mysql-index.html






# 笔记-『浅入浅出』MySQL 和 InnoDB
https://draveness.me/mysql-innodb/

*存储*
tablespace->segment->extent->page->row
innodb_page_size = 16KB
表的定义和索引分开存储（表的定义：.idb；索引：.frm）



Compact 和 Redundant 格式最大的不同就是记录格式的第一个部分；在 Compact 中，行记录的第一部分倒序存放了一行数据中列的长度（Length），而 Redundant 中存的是每一列的偏移量（Offset），从总体上上看，Compact 行记录格式相比 Redundant 格式能够减少 20% 的存储空间。



行溢出数据


### 数据页结构
页是 InnoDB 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面



内部的 Page Header/Page Directory 关心的是页的状态信息，
而 Fil Header/Fil Trailer 关心的是记录页的头信息

Infimum 和 Supremum 这两个虚拟的记录（可以理解为占位符），Infimum 记录是比该页中任何主键值都要小的值，Supremum 是该页中的最大值：



User Records 就是整个页面中真正用于存放行记录的部分，而 Free Space 就是空余空间了，它是一个链表的数据结构，为了保证插入和删除的效率，整个页面并不会按照主键顺序对所有记录进行排序，它会自动从左侧向右寻找空白节点进行插入




## 索引
### 索引的数据结构
整个页面并不会按照主键顺序对所有记录进行排序，它会自动从左侧向右寻找空白节点进行插入，行记录在物理存储上并不是按照顺序的，它们之间的顺序是由 next_record 这一指针控制的。


### 数据页结构

InnoDB 存储引擎在绝大多数情况下使用 B+ 树建立索引，这是关系型数据库中查找最为常用和有效的索引，但是 B+ 树索引并不能找到一个给定键对应的具体值，它只能找到数据行对应的页,数据库把整个页读入到内存中，并在内存中查找具体的数据行。

行记录在物理存储上并不是按照顺序的，它们之间的顺序是由 next_record 这一指针控制的。

B+ 树是平衡树，它查找任意节点所耗费的时间都是完全相同的，比较的次数就是 B+ 树的高度；


### 聚集索引和辅助索引
聚集索引中存放着一条行记录的全部信息，
而辅助索引中只包含索引列和一个用于查找对应行记录的『书签』

#### 聚集索引

聚集索引就是按照表中主键的顺序构建一颗 B+ 树，并在叶节点中存放表中的行记录数据。

#### 辅助索引(非聚集索引)

辅助索引也是通过 B+ 树实现的，但是它的叶节点并不包含行记录的全部数据，仅包含索引中的所有键和一个用于查找对应行记录的『书签』，在 InnoDB 中这个书签就是当前记录的主键。


#### 索引的设计
参考《数据库索引设计与优化》


## 锁

### 并发控制机制
InnoDB 存储引擎中使用的就是悲观锁

乐观锁是一种思想，它其实并不是一种真正的『锁』，它会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都没有对数据库进行加锁；

悲观锁就是一种真正的锁了，它会在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源；


### 锁的种类
共享锁（读锁）：允许事务对一条行数据进行读取；
互斥锁（写锁）：允许事务对一条行数据进行删除或更新；

共享锁之间是兼容的，而互斥锁与其他任意锁都不兼容：

### 锁的粒度
InnoDB 支持多种粒度的锁，也就是行锁和表锁；意向锁就是一种表级锁。
行锁
表锁
意向锁：意向锁其实不会阻塞全表扫描之外的任何请求，它们的主要目的是为了表示是否有人请求锁定表中的某一行数据。是预见是否存在行锁的一种方法。

意向共享锁：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁；
意向互斥锁：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁；


### 锁的算法
Record Lock：
where条件中有字段，使得能通索引定位的recodrd，使用用记录锁，否则使用行锁
Gap Lock：
where条件中有字段，使得能通过索引定位一个连续区域，使用间隙锁；
Next-Key Lock：
它是记录锁和记录前的间隙锁的结合，Next-Key 锁锁定的是当前值和前面的范围，Next-Key 锁的作用其实是为了解决幻读的问题，

### 死锁的发生
两个事务（t1，t2），各需要两把锁（A，B），相互支持对方需要的锁，事务不能结束，造成死锁
持有：t1：A  t2:B
需要：t1：B	t2:A



## 事务与隔离级别

RAED UNCOMMITED：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；

读取到了其他事务没有提交的数据

READ COMMITED：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；

多次读取，读到了其他事务的提交的修改，造成多次读取到的数据不一致，可以通过加行锁来解决

REPEATABLE READ：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；

多次读取，读到了其他事务添加的新数据，造成多次读区到的数据不一致，可以通过加间隙锁来解决


SERIALIZABLE：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；




原文：
RAED UNCOMMITED：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；
READ COMMITED：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；


我理解是：
脏读，和不可重复读的原因好像有问题，
RAED UNCOMMITED：事务没有commit就落地盘，可能造成其他事务会读到未提交的行（Dirty Read）；
READ COMMITED：事务中select没有行锁，可能会读取到其他事务commit的修改。造成不可重复读（Non-Repeatable Read）；

并且，与下文中描述的原因也不一致

原文：
脏读
在一个事务中，读取了其他事务未提交的数据。
不可重复读
在一个事务中，同一行记录被访问了两次却得到了不同的结果。




# 笔记-MySQL 索引设计概要
https://draveness.me/sql-index-intro/


## 磁盘 IO
都会将该行或者多行所在的页全部加载进来，

### 随机读取
内存池<=内存读取《-磁盘

### 查询过程
#### 索引片
索引片其实就是 SQL 查询在执行过程中扫描的一个索引片段

#### 过滤因子
满足查询条件的记录行数所占的比例：

#### 匹配列与过滤列
匹配列：等值谓词
过滤列：范围谓词


## 索引的设计

### 三星索引，创建步骤
- 所有等值谓词中的列，作为索引开头的最开始的列（任意顺序）；
	建立必要索引，还能减少索引片的大小以减少需要扫描的数据行；
- 将 ORDER BY 列加入索引中
	排序的时候可以利用索引来排序
- 将查询语句剩余的列全部加入到索引中
	查询到数据之后，直接返回，避免回表





# MySQL 索引性能分析概要
https://draveness.me/sql-index-performance/


# 为什么 MySQL 使用 B+ 树
https://draveness.me/whys-the-design-mysql-b-plus-tree/
## 概述
## 设计
### 读写性能
hash索引在飞主键查询，处理范围查询，排序性能会非常差
B+树能够保证数据按照键的顺序进行存储

### 数据加载
B 树与 B+ 树的最大区别就是，
B 树可以在非叶结点中存储数据
B+ 树的所有数据其实都存储在叶子节点中，而这些叶节点可以通过『指针』依次按顺序连接

hash：范围查询和排序的时候，利用不了索引
B树：在范围查询的时候，要进行多次随机io


哈希：哈希虽然能够提供 O(1) 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；
B 树： B 树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O；


B+ 树这种数据结构会增加树的高度从而增加整体的耗时，然而高度为 3 的 B+ 树就能够存储千万级别的数据，实践中 B+ 树的高度最多也就 4 或者 5



# 为什么 MongoDB 使用 B 树
https://draveness.me/whys-the-design-mongodb-b-tree/

## 概述
MongoDB 使用了 WiredTiger 作为默认的存储引擎


## 设计
* 作为非关系型的数据库，MongoDB 对于遍历数据的需求没有关系型数据库那么强，它追求的是读写单个记录的性能；
* 大多数的数据库面对的都是读多写少的场景，B 树与 LSM 树在该场景下有更大的优势；

## 非关系型
而在 MongoDB 假设的场景中遍历数据并不是常见的需求。


MySQL 认为遍历数据的查询是常见的，所以它选择 B+ 树作为底层数据结构，而舍弃了通过非叶节点存储数据这一特性
MongoDB 认为查询单个数据记录远比遍历数据更加常见，由于 B 树的非叶结点也可以存储数据，所以查询一条数据所需要的平均随机 IO 次数会比 B+ 树少，


MongoDB 中推荐的设计方法，其实是使用嵌入文档，将 post 和属于它的所有 comments 都存储到一起：


MySQL 使用 B+ 树是因为数据的遍历在关系型数据库中非常常见，它经常需要处理各个表之间的关系并通过范围查询一些数据；
但是 MongoDB 作为面向文档的数据库，与数据之间的关系相比，它更看重以文档为中心的组织方式，所以选择了查询单个文档性能较好的 B 树，这个选择对遍历数据的查询也可以保证可以接受的时延；

LSM 树是一种专门用来优化写入的数据结构，它将随机写变成了顺序写显著地提高了写入性能，但是却牺牲了读的效率，这与大多数场景需要的特点是不匹配的，所以 MongoDB 最终还是选择读取性能更好的 B 树作为默认的数据结构；



b+的叶子结点不存放数据，b存放数据，需要再看看





