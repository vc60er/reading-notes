
## DHT

分布式哈希表（distributed hash table，缩写DHT）是分布式计算系统中的一类，用来将一个键（key）的集合分散到所有在分布式系统中的节点。

分布式散列表本质上强调以下特性：

- 离散性：构成系统的节点并没有任何中央式的协调机制。
- 伸缩性：即使有成千上万个节点，系统仍然应该十分有效率。
- 容错性：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度。


基本概念

- 键空间（keyspace），例如说所有160位长的字符串集合。
- 键空间分区（keyspace partitioning）将键空间分区成数个，并指定到在此系统的节点中。
- 而延展网络则连接这些节点，并让他们能够借由在键空间内的任一值找到拥有该值的节点




### Kademlia算法

映射key和节点的路由算法


**存储**

- 映射规则

使用二叉树存储key的160位hash值，从更节点遍历到叶子结点的路径能组成key的hash值

- 二叉树的拆分规则

先从根节点开始，把不包含自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的第二层子树；以此类推，直到最后只剩下自己。

- 拆子树

K-桶（K-bucket）：子树中的已知节点，为了增强系统的鲁棒性，一般大于 k > 1 

每个节点在完成子树拆分后，要记录每个子树里面的 K 个节点。


- Kademlia




**距离计算**

这些节点通过一组数字（或称为节点ID）来进行身份标识。节点ID不仅可以用来做身份标识，还可以用来进行值定位（值通常是文件的散列或者关键词）。


Kademlia简称为Kad,它使用了一个精妙的算法，来计算节点之间的"距离" (这里的距离不是地理空间的距离，而是路由的跳数)，这个算法就是XOR操作(异或)，因为这个操作和距离的计算类似：

(A ⊕ B) == (B ⊕ A): XOR 符合“交换律”，具备对称性。A和B的距离从哪一个节点计算都是相同的。
(A ⊕ A) == 0: 反身性，自己和自己的距离为零。
(A ⊕ B) > 0: 两个不同的 key 之间的距离必大于零。
(A ⊕ B) + (B ⊕ C) >= (A ⊕ C): 三角不等式, A经过B到C的距离总是大于A直接到C的距离。




节点：
存放文件的下载信息的地方（如：地址，端口，文件名），
一个节点存放最近各多个文件的信息
节点ID随机产生


文件ID：
	文件的160位hash


**参考**

- [五、分布式哈希表(DHT)原理:从BT种子和磁力链接说起](https://alexanderli95.com/2019/07/10/%E4%BA%94%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8DHT%E5%8E%9F%E7%90%86,%E4%BB%8EBT%E7%A7%8D%E5%AD%90%E5%92%8C%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5%E8%AF%B4%E8%B5%B7/)

- [聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad） 和 Chord 为例](https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html)

- [DHT 分布式哈希表](https://colobu.com/2018/03/26/distributed-hash-table/)

- [Distributed Hash Tables, Part I](https://www.linuxjournal.com/article/6797)
- [Kademlia](https://en.wikipedia.org/wiki/Kademlia)


